// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: YahooFinancePricingData.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct yaticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var price: Float {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  var quoteType: yaticker.QuoteType {
    get {return _storage._quoteType}
    set {_uniqueStorage()._quoteType = newValue}
  }

  var marketHours: yaticker.MarketHoursType {
    get {return _storage._marketHours}
    set {_uniqueStorage()._marketHours = newValue}
  }

  var changePercent: Float {
    get {return _storage._changePercent}
    set {_uniqueStorage()._changePercent = newValue}
  }

  var dayVolume: Int64 {
    get {return _storage._dayVolume}
    set {_uniqueStorage()._dayVolume = newValue}
  }

  var dayHigh: Float {
    get {return _storage._dayHigh}
    set {_uniqueStorage()._dayHigh = newValue}
  }

  var dayLow: Float {
    get {return _storage._dayLow}
    set {_uniqueStorage()._dayLow = newValue}
  }

  var change: Float {
    get {return _storage._change}
    set {_uniqueStorage()._change = newValue}
  }

  var shortName: String {
    get {return _storage._shortName}
    set {_uniqueStorage()._shortName = newValue}
  }

  var expireDate: Int64 {
    get {return _storage._expireDate}
    set {_uniqueStorage()._expireDate = newValue}
  }

  var openPrice: Float {
    get {return _storage._openPrice}
    set {_uniqueStorage()._openPrice = newValue}
  }

  var previousClose: Float {
    get {return _storage._previousClose}
    set {_uniqueStorage()._previousClose = newValue}
  }

  var strikePrice: Float {
    get {return _storage._strikePrice}
    set {_uniqueStorage()._strikePrice = newValue}
  }

  var underlyingSymbol: String {
    get {return _storage._underlyingSymbol}
    set {_uniqueStorage()._underlyingSymbol = newValue}
  }

  var openInterest: Int64 {
    get {return _storage._openInterest}
    set {_uniqueStorage()._openInterest = newValue}
  }

  var optionsType: yaticker.OptionType {
    get {return _storage._optionsType}
    set {_uniqueStorage()._optionsType = newValue}
  }

  var miniOption: Int64 {
    get {return _storage._miniOption}
    set {_uniqueStorage()._miniOption = newValue}
  }

  var lastSize: Int64 {
    get {return _storage._lastSize}
    set {_uniqueStorage()._lastSize = newValue}
  }

  var bid: Float {
    get {return _storage._bid}
    set {_uniqueStorage()._bid = newValue}
  }

  var bidSize: Int64 {
    get {return _storage._bidSize}
    set {_uniqueStorage()._bidSize = newValue}
  }

  var ask: Float {
    get {return _storage._ask}
    set {_uniqueStorage()._ask = newValue}
  }

  var askSize: Int64 {
    get {return _storage._askSize}
    set {_uniqueStorage()._askSize = newValue}
  }

  var priceHint: Int64 {
    get {return _storage._priceHint}
    set {_uniqueStorage()._priceHint = newValue}
  }

  var vol24Hr: Int64 {
    get {return _storage._vol24Hr}
    set {_uniqueStorage()._vol24Hr = newValue}
  }

  var volAllCurrencies: Int64 {
    get {return _storage._volAllCurrencies}
    set {_uniqueStorage()._volAllCurrencies = newValue}
  }

  var fromcurrency: String {
    get {return _storage._fromcurrency}
    set {_uniqueStorage()._fromcurrency = newValue}
  }

  var lastMarket: String {
    get {return _storage._lastMarket}
    set {_uniqueStorage()._lastMarket = newValue}
  }

  var circulatingSupply: Double {
    get {return _storage._circulatingSupply}
    set {_uniqueStorage()._circulatingSupply = newValue}
  }

  var marketcap: Double {
    get {return _storage._marketcap}
    set {_uniqueStorage()._marketcap = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum QuoteType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case altsymbol // = 5
    case heartbeat // = 7
    case equity // = 8
    case index // = 9
    case mutualfund // = 11
    case moneymarket // = 12
    case option // = 13
    case currency // = 14
    case warrant // = 15
    case bond // = 17
    case future // = 18
    case etf // = 20
    case commodity // = 23
    case ecnquote // = 28
    case cryptocurrency // = 41
    case indicator // = 42
    case industry // = 1000
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 5: self = .altsymbol
      case 7: self = .heartbeat
      case 8: self = .equity
      case 9: self = .index
      case 11: self = .mutualfund
      case 12: self = .moneymarket
      case 13: self = .option
      case 14: self = .currency
      case 15: self = .warrant
      case 17: self = .bond
      case 18: self = .future
      case 20: self = .etf
      case 23: self = .commodity
      case 28: self = .ecnquote
      case 41: self = .cryptocurrency
      case 42: self = .indicator
      case 1000: self = .industry
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .altsymbol: return 5
      case .heartbeat: return 7
      case .equity: return 8
      case .index: return 9
      case .mutualfund: return 11
      case .moneymarket: return 12
      case .option: return 13
      case .currency: return 14
      case .warrant: return 15
      case .bond: return 17
      case .future: return 18
      case .etf: return 20
      case .commodity: return 23
      case .ecnquote: return 28
      case .cryptocurrency: return 41
      case .indicator: return 42
      case .industry: return 1000
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum OptionType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case call // = 0
    case put // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .call
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .call
      case 1: self = .put
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .call: return 0
      case .put: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum MarketHoursType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case preMarket // = 0
    case regularMarket // = 1
    case postMarket // = 2
    case extendedHoursMarket // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .preMarket
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .preMarket
      case 1: self = .regularMarket
      case 2: self = .postMarket
      case 3: self = .extendedHoursMarket
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .preMarket: return 0
      case .regularMarket: return 1
      case .postMarket: return 2
      case .extendedHoursMarket: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension yaticker.QuoteType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [yaticker.QuoteType] = [
    .none,
    .altsymbol,
    .heartbeat,
    .equity,
    .index,
    .mutualfund,
    .moneymarket,
    .option,
    .currency,
    .warrant,
    .bond,
    .future,
    .etf,
    .commodity,
    .ecnquote,
    .cryptocurrency,
    .indicator,
    .industry,
  ]
}

extension yaticker.OptionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [yaticker.OptionType] = [
    .call,
    .put,
  ]
}

extension yaticker.MarketHoursType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [yaticker.MarketHoursType] = [
    .preMarket,
    .regularMarket,
    .postMarket,
    .extendedHoursMarket,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension yaticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "yaticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
    4: .same(proto: "currency"),
    5: .same(proto: "exchange"),
    6: .same(proto: "quoteType"),
    7: .same(proto: "marketHours"),
    8: .same(proto: "changePercent"),
    9: .same(proto: "dayVolume"),
    10: .same(proto: "dayHigh"),
    11: .same(proto: "dayLow"),
    12: .same(proto: "change"),
    13: .same(proto: "shortName"),
    14: .same(proto: "expireDate"),
    15: .same(proto: "openPrice"),
    16: .same(proto: "previousClose"),
    17: .same(proto: "strikePrice"),
    18: .same(proto: "underlyingSymbol"),
    19: .same(proto: "openInterest"),
    20: .same(proto: "optionsType"),
    21: .same(proto: "miniOption"),
    22: .same(proto: "lastSize"),
    23: .same(proto: "bid"),
    24: .same(proto: "bidSize"),
    25: .same(proto: "ask"),
    26: .same(proto: "askSize"),
    27: .same(proto: "priceHint"),
    28: .standard(proto: "vol_24hr"),
    29: .same(proto: "volAllCurrencies"),
    30: .same(proto: "fromcurrency"),
    31: .same(proto: "lastMarket"),
    32: .same(proto: "circulatingSupply"),
    33: .same(proto: "marketcap"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _price: Float = 0
    var _time: Int64 = 0
    var _currency: String = String()
    var _exchange: String = String()
    var _quoteType: yaticker.QuoteType = .none
    var _marketHours: yaticker.MarketHoursType = .preMarket
    var _changePercent: Float = 0
    var _dayVolume: Int64 = 0
    var _dayHigh: Float = 0
    var _dayLow: Float = 0
    var _change: Float = 0
    var _shortName: String = String()
    var _expireDate: Int64 = 0
    var _openPrice: Float = 0
    var _previousClose: Float = 0
    var _strikePrice: Float = 0
    var _underlyingSymbol: String = String()
    var _openInterest: Int64 = 0
    var _optionsType: yaticker.OptionType = .call
    var _miniOption: Int64 = 0
    var _lastSize: Int64 = 0
    var _bid: Float = 0
    var _bidSize: Int64 = 0
    var _ask: Float = 0
    var _askSize: Int64 = 0
    var _priceHint: Int64 = 0
    var _vol24Hr: Int64 = 0
    var _volAllCurrencies: Int64 = 0
    var _fromcurrency: String = String()
    var _lastMarket: String = String()
    var _circulatingSupply: Double = 0
    var _marketcap: Double = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _price = source._price
      _time = source._time
      _currency = source._currency
      _exchange = source._exchange
      _quoteType = source._quoteType
      _marketHours = source._marketHours
      _changePercent = source._changePercent
      _dayVolume = source._dayVolume
      _dayHigh = source._dayHigh
      _dayLow = source._dayLow
      _change = source._change
      _shortName = source._shortName
      _expireDate = source._expireDate
      _openPrice = source._openPrice
      _previousClose = source._previousClose
      _strikePrice = source._strikePrice
      _underlyingSymbol = source._underlyingSymbol
      _openInterest = source._openInterest
      _optionsType = source._optionsType
      _miniOption = source._miniOption
      _lastSize = source._lastSize
      _bid = source._bid
      _bidSize = source._bidSize
      _ask = source._ask
      _askSize = source._askSize
      _priceHint = source._priceHint
      _vol24Hr = source._vol24Hr
      _volAllCurrencies = source._volAllCurrencies
      _fromcurrency = source._fromcurrency
      _lastMarket = source._lastMarket
      _circulatingSupply = source._circulatingSupply
      _marketcap = source._marketcap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._price) }()
        case 3: try { try decoder.decodeSingularSInt64Field(value: &_storage._time) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._quoteType) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._marketHours) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._changePercent) }()
        case 9: try { try decoder.decodeSingularSInt64Field(value: &_storage._dayVolume) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._dayHigh) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._dayLow) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._change) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._shortName) }()
        case 14: try { try decoder.decodeSingularSInt64Field(value: &_storage._expireDate) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._openPrice) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._previousClose) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._strikePrice) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._underlyingSymbol) }()
        case 19: try { try decoder.decodeSingularSInt64Field(value: &_storage._openInterest) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._optionsType) }()
        case 21: try { try decoder.decodeSingularSInt64Field(value: &_storage._miniOption) }()
        case 22: try { try decoder.decodeSingularSInt64Field(value: &_storage._lastSize) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._bid) }()
        case 24: try { try decoder.decodeSingularSInt64Field(value: &_storage._bidSize) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._ask) }()
        case 26: try { try decoder.decodeSingularSInt64Field(value: &_storage._askSize) }()
        case 27: try { try decoder.decodeSingularSInt64Field(value: &_storage._priceHint) }()
        case 28: try { try decoder.decodeSingularSInt64Field(value: &_storage._vol24Hr) }()
        case 29: try { try decoder.decodeSingularSInt64Field(value: &_storage._volAllCurrencies) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._fromcurrency) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._lastMarket) }()
        case 32: try { try decoder.decodeSingularDoubleField(value: &_storage._circulatingSupply) }()
        case 33: try { try decoder.decodeSingularDoubleField(value: &_storage._marketcap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._price != 0 {
        try visitor.visitSingularFloatField(value: _storage._price, fieldNumber: 2)
      }
      if _storage._time != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._time, fieldNumber: 3)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 4)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 5)
      }
      if _storage._quoteType != .none {
        try visitor.visitSingularEnumField(value: _storage._quoteType, fieldNumber: 6)
      }
      if _storage._marketHours != .preMarket {
        try visitor.visitSingularEnumField(value: _storage._marketHours, fieldNumber: 7)
      }
      if _storage._changePercent != 0 {
        try visitor.visitSingularFloatField(value: _storage._changePercent, fieldNumber: 8)
      }
      if _storage._dayVolume != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._dayVolume, fieldNumber: 9)
      }
      if _storage._dayHigh != 0 {
        try visitor.visitSingularFloatField(value: _storage._dayHigh, fieldNumber: 10)
      }
      if _storage._dayLow != 0 {
        try visitor.visitSingularFloatField(value: _storage._dayLow, fieldNumber: 11)
      }
      if _storage._change != 0 {
        try visitor.visitSingularFloatField(value: _storage._change, fieldNumber: 12)
      }
      if !_storage._shortName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortName, fieldNumber: 13)
      }
      if _storage._expireDate != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._expireDate, fieldNumber: 14)
      }
      if _storage._openPrice != 0 {
        try visitor.visitSingularFloatField(value: _storage._openPrice, fieldNumber: 15)
      }
      if _storage._previousClose != 0 {
        try visitor.visitSingularFloatField(value: _storage._previousClose, fieldNumber: 16)
      }
      if _storage._strikePrice != 0 {
        try visitor.visitSingularFloatField(value: _storage._strikePrice, fieldNumber: 17)
      }
      if !_storage._underlyingSymbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._underlyingSymbol, fieldNumber: 18)
      }
      if _storage._openInterest != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._openInterest, fieldNumber: 19)
      }
      if _storage._optionsType != .call {
        try visitor.visitSingularEnumField(value: _storage._optionsType, fieldNumber: 20)
      }
      if _storage._miniOption != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._miniOption, fieldNumber: 21)
      }
      if _storage._lastSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._lastSize, fieldNumber: 22)
      }
      if _storage._bid != 0 {
        try visitor.visitSingularFloatField(value: _storage._bid, fieldNumber: 23)
      }
      if _storage._bidSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._bidSize, fieldNumber: 24)
      }
      if _storage._ask != 0 {
        try visitor.visitSingularFloatField(value: _storage._ask, fieldNumber: 25)
      }
      if _storage._askSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._askSize, fieldNumber: 26)
      }
      if _storage._priceHint != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._priceHint, fieldNumber: 27)
      }
      if _storage._vol24Hr != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._vol24Hr, fieldNumber: 28)
      }
      if _storage._volAllCurrencies != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._volAllCurrencies, fieldNumber: 29)
      }
      if !_storage._fromcurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fromcurrency, fieldNumber: 30)
      }
      if !_storage._lastMarket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastMarket, fieldNumber: 31)
      }
      if _storage._circulatingSupply != 0 {
        try visitor.visitSingularDoubleField(value: _storage._circulatingSupply, fieldNumber: 32)
      }
      if _storage._marketcap != 0 {
        try visitor.visitSingularDoubleField(value: _storage._marketcap, fieldNumber: 33)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: yaticker, rhs: yaticker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._quoteType != rhs_storage._quoteType {return false}
        if _storage._marketHours != rhs_storage._marketHours {return false}
        if _storage._changePercent != rhs_storage._changePercent {return false}
        if _storage._dayVolume != rhs_storage._dayVolume {return false}
        if _storage._dayHigh != rhs_storage._dayHigh {return false}
        if _storage._dayLow != rhs_storage._dayLow {return false}
        if _storage._change != rhs_storage._change {return false}
        if _storage._shortName != rhs_storage._shortName {return false}
        if _storage._expireDate != rhs_storage._expireDate {return false}
        if _storage._openPrice != rhs_storage._openPrice {return false}
        if _storage._previousClose != rhs_storage._previousClose {return false}
        if _storage._strikePrice != rhs_storage._strikePrice {return false}
        if _storage._underlyingSymbol != rhs_storage._underlyingSymbol {return false}
        if _storage._openInterest != rhs_storage._openInterest {return false}
        if _storage._optionsType != rhs_storage._optionsType {return false}
        if _storage._miniOption != rhs_storage._miniOption {return false}
        if _storage._lastSize != rhs_storage._lastSize {return false}
        if _storage._bid != rhs_storage._bid {return false}
        if _storage._bidSize != rhs_storage._bidSize {return false}
        if _storage._ask != rhs_storage._ask {return false}
        if _storage._askSize != rhs_storage._askSize {return false}
        if _storage._priceHint != rhs_storage._priceHint {return false}
        if _storage._vol24Hr != rhs_storage._vol24Hr {return false}
        if _storage._volAllCurrencies != rhs_storage._volAllCurrencies {return false}
        if _storage._fromcurrency != rhs_storage._fromcurrency {return false}
        if _storage._lastMarket != rhs_storage._lastMarket {return false}
        if _storage._circulatingSupply != rhs_storage._circulatingSupply {return false}
        if _storage._marketcap != rhs_storage._marketcap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension yaticker.QuoteType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    5: .same(proto: "ALTSYMBOL"),
    7: .same(proto: "HEARTBEAT"),
    8: .same(proto: "EQUITY"),
    9: .same(proto: "INDEX"),
    11: .same(proto: "MUTUALFUND"),
    12: .same(proto: "MONEYMARKET"),
    13: .same(proto: "OPTION"),
    14: .same(proto: "CURRENCY"),
    15: .same(proto: "WARRANT"),
    17: .same(proto: "BOND"),
    18: .same(proto: "FUTURE"),
    20: .same(proto: "ETF"),
    23: .same(proto: "COMMODITY"),
    28: .same(proto: "ECNQUOTE"),
    41: .same(proto: "CRYPTOCURRENCY"),
    42: .same(proto: "INDICATOR"),
    1000: .same(proto: "INDUSTRY"),
  ]
}

extension yaticker.OptionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL"),
    1: .same(proto: "PUT"),
  ]
}

extension yaticker.MarketHoursType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRE_MARKET"),
    1: .same(proto: "REGULAR_MARKET"),
    2: .same(proto: "POST_MARKET"),
    3: .same(proto: "EXTENDED_HOURS_MARKET"),
  ]
}
